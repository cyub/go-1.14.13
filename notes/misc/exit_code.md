## 具有特殊含义的退出码

退出码  |  含义  |  示例  |  说明
--- | --- | --- | ---
1  |  一般错误的集合  |  let "var1 = 1/0"  |  各种杂项错误，例如“除以零”和其他不允许的操作
2  |  错误使用 Shell 内置命令（根据 Bash 文档）  |  empty_function() {}  |  缺少关键字或命令，或权限问题
126  |  调用的命令无法执行  |  /dev/null  |  权限问题或命令不是可执行文件
127  |  “命令未找到”  |  illegal_command  |  $PATH 可能存在问题或打错字
128  |  exit 命令参数无效  |  exit 3.14159  |  exit 命令只接受范围在 0 到 255 的整数参数
128+n  |  致命错误信号“n”  |  kill -9 $PPID of script  |  $? 返回 137（128 + 9）
130  |  脚本被 Control-C 终止  |  Ctl-C  |  Control-C 是致命错误信号 2（130 = 128 + 2，请参阅上文）
255*  |  退出状态超出范围  |  exit -1  |  exit 命令只接受范围在 0 到 255 的整数参数

根据上表，退出码 1-2，126-165和255 具有特殊含义，因此应避免将其用于用户指定的退出参数。以退出码 127 结尾的脚本肯定会在故障排除时造成混淆（错误代码是“命令未找到”还是用户定义的代码？）。然而，许多脚本在遇到错误时使用退出码 1 作为一般性故障转移。由于退出码 1 表示许多可能的错误，因此在调试中并不特别有用。

已经有人试图系统化退出状态号码（请参阅 /usr/include/sysexits.h），但这是为 C 和 C++ 程序员而设计的。为脚本编写类似的标准可能是合适的。本文档的作者建议将用户定义的退出代码限制为 64-113 范围内的代码（以及成功的代码 0），以符合 C/C++ 标准。这将分配 50 个有效代码，并使脚本故障排除更加直接。

从 shell 脚本退出后在命令行中发出 $? 仅在 Bash 或 sh 提示符下才会产生与上表一致的结果。运行 C-shell 或 tcsh 在某些情况下可能会产生不同的值。

注意：

- 超出范围的退出值可能导致意外的退出代码。大于 255 的退出值返回一个退出代码模数 256。例如，exit 3809 给出一个退出代码 225（3809％256 = 225）。

- /usr/include/sysexits.h 的更新分配了先前未使用的退出代码从 64-78。可以预期未分配退出代码的范围将在将来进一步限制。本文档的作者不会对脚本示例进行修复以符合不断变化的标准。这不应该造成任何问题，因为在编译的 C/C++ 二进制文件和 shell 脚本之间的退出代码使用中不存在重叠或冲突。

## 来源

- [Advanced Bash-Scripting Guide：Appendix E. Exit Codes With Special Meanings](https://tldp.org/LDP/abs/html/exitcodes.html)